"""Module implementing a virtual interface for the Copper Mountain Cobalt series of VNAs."""

from __future__ import annotations

import sys
import typing
from enum import Enum

import skrf
from skrf.vi import vna
from skrf.vi.validators import (
    BooleanValidator,
    EnumValidator,
    FreqValidator,
    IntValidator,
)

if typing.TYPE_CHECKING:
    from numpy.typing import NDArray

import re


class SweepType(Enum):
    LINEAR = "LIN"
    LOG = "LOG"
    SEGMENT = "SEGM"
    POWER = "POW"
    CW = "CW"


class TraceParameter(Enum):
    S11 = "S11"
    S12 = "S12"
    S21 = "S21"
    S22 = "S22"


class TriggerSource(Enum):
    """Four trigger sources are supported in the Cobalt series.

    Internal: The analyzer generates a trigger signal automatically.
    External: The trigger is a logic signal at the trigger input port.
    Bus: The trigger is generated by SCPI or COM commands.
    Manual: The trigger is manual presses of the Trigger software key.
    """

    INTERNAL = "INT"
    EXTERNAL = "EXT"
    MANUAL = "MAN"
    BUS = "BUS"


class TriggerScope(Enum):
    ALL = "ALL"
    ACTIVE = "ACTIVE"


class TriggerState(Enum):
    CONT = "CONT"
    SINGLE = "SINGLE"
    HOLD = "HOLD"


class Cobalt(vna.VNA):
    """Copper Mountain Technologies Cobalt series.

    Cobalt Models
    ==========
    C4220

    """

    _models: typing.ClassVar = {
        "C4220": {"nports": 2, "unsupported": []},
    }

    class Channel(vna.Channel):
        def __init__(self, parent: vna.VNA, cnum: int, cname: str):
            super().__init__(parent, cnum, cname)

        freq_start = vna.VNA.command(
            get_cmd="SENS<self:cnum>:FREQ:STAR?",
            set_cmd="SENS<self:cnum>:FREQ:STAR <arg>",
            doc="""The start frequency [Hz].

            Stimulus > Start""",
            validator=FreqValidator(),
        )

        freq_stop = vna.VNA.command(
            get_cmd="SENS<self:cnum>:FREQ:STOP?",
            set_cmd="SENS<self:cnum>:FREQ:STOP <arg>",
            doc="""The stop frequency [Hz].

            Stimulus > Stop""",
            validator=FreqValidator(),
        )

        freq_span = vna.VNA.command(
            get_cmd="SENS<self:cnum>:FREQ:SPAN?",
            set_cmd="SENS<self:cnum>:FREQ:SPAN <arg>",
            doc="""The frequency span [Hz].

            Stimulus > Span""",
            validator=FreqValidator(),
        )

        freq_center = vna.VNA.command(
            get_cmd="SENS<self:cnum>:FREQ:CENT?",
            set_cmd="SENS<self:cnum>:FREQ:CENT <arg>",
            doc="""The frequency center [Hz].

            Stimulus > Center""",
            validator=FreqValidator(),
        )

        npoints = vna.VNA.command(
            get_cmd="SENS<self:cnum>:SWE:POIN?",
            set_cmd="SENS<self:cnum>:SWE:POIN <arg>",
            doc="""The number of frequency points. Sets the frequency step as a side effect.

            Stimulus > Points
            """,
            validator=IntValidator(),
        )

        if_bandwidth = vna.VNA.command(
            get_cmd="SENS<self:cnum>:BWID?",
            set_cmd="SENS<self:cnum>:BWID <arg>",
            doc="""Sets or reads out the IF bandwidth in Hz. Resolution must be in
            steps of 1, 1.5, 2, 3, 5, 7.

            Average > IF Bandwidth""",
            validator=FreqValidator(),
        )

        sweep_type = vna.VNA.command(
            get_cmd="SENS<self:cnum>:SWE:TYPE?",
            set_cmd="SENS<self:cnum>:SWE:TYPE <arg>",
            doc="""The type of sweep (linear, log, etc)

            Stimulus > Sweep Type""",
            validator=EnumValidator(SweepType),
        )

        averaging_on = vna.VNA.command(
            get_cmd="SENS<self:cnum>:AVER:STATE?",
            set_cmd="SENS<self:cnum>:AVER:STATE <arg>",
            doc="""Whether averaging is on or off

            Average > Averaging [ON | OFF]""",
            validator=BooleanValidator(),
        )

        averaging_count = vna.VNA.command(
            get_cmd="SENS<self:cnum>:AVER:COUN?",
            set_cmd="SENS<self:cnum>:AVER:COUN <arg>",
            doc="""Sets or reads out the averaging factor when
            averaging is turned on.

            Averaging > Avg Factor""",
            validator=IntValidator(1, 65536),
        )

        active_trace = vna.VNA.command(
            get_cmd="SERV:CHAN<self:cnum>:TRAC:ACT?",
            set_cmd="CALC<self:cnum>:PAR<arg>:SEL",
            doc="""The active trace.

            Display > Active Trace/Channel""",
            validator=IntValidator(1, 16),
        )

        ntraces = vna.VNA.command(
            get_cmd="CALC<self:cnum>:PAR:COUN?",
            set_cmd="CALC<self:cnum>:PAR:COUN <arg>",
            doc="""Number of traces.

            Display > Num of Traces""",
            validator=IntValidator(1, 16),
        )

        param_def = vna.VNA.command(
            get_cmd="CALC<self:cnum>:PAR<self:active_trace>:DEF?",
            set_cmd="CALC<self:cnum>:PAR<self:active_trace>:DEF <arg>",
            doc=""""Selects the measurement parameter of the trace.

            Measurement""",
            validator=EnumValidator(TraceParameter),
        )

        trigger_cont = vna.VNA.command(
            get_cmd="INIT<self:cnum>:CONT?",
            set_cmd="INIT<self:cnum>:CONT <arg>",
            doc="""Turns the continuous trigger initiation mode on or off.

            When the continUous mode is ON:
             - If the trigger source is INT, the Analyzer automatically continuously sweeps.
             - If it the trigger source is not INT, the Analyzer goes into the continuous waiting state.
             - For the BUS source, a sweep starts by sending one of the TRIG command.

            If continuous mode is OFF, the Analyzer is put in the SINGLE state, and a sweep is triggered by INIT.

            Stimulus > Trigger > Continuous
            Stimulus > Trigger > Hold""",
            validator=BooleanValidator(),
        )

        @property
        def freq_step(self) -> int:
            """Retrieve frequency step.

            Returns
            -------
            int
                Frequency step.
            """
            f = self.frequency
            return int(f.step)

        @freq_step.setter
        def freq_step(self, value: float | str) -> None:
            f: int = FreqValidator().validate_input(value)
            freq = self.frequency
            self.npoints = len(range(int(freq.start), int(freq.stop) + f, f))

        @property
        def frequency(self) -> skrf.Frequency:
            """Retrieve frequency object.

            Returns
            -------
            skrf.Frequency
                Frequency array.
            """
            f = skrf.Frequency(
                start=self.freq_start,
                stop=self.freq_stop,
                npoints=self.npoints,
                unit="Hz",
            )
            return f

        @frequency.setter
        def frequency(self, f: skrf.Frequency) -> None:
            self.freq_start = f.start
            self.freq_stop = f.stop
            self.npoints = f.npoints

        @property
        def active_trace_sdata(self) -> NDArray:
            """Query active trace S-matrix data.

            Returns
            -------
            numpy.ndarray
                Array of S-parameters.
            """
            return self.query_values(f"CALC{self.cnum}:SEL:DATA:SDAT?", complex_values=True)

        def clear_averaging(self) -> None:
            """Restarts the averaging process when the averaging is turned on.

            No directly equivalent softkey.
            """
            self.write(f"SENS{self.cnum}:AVER:CLE")

        def get_active_trace_sdata(self) -> skrf.Network:
            """Retrieve the active trace S-parameters as a Network.

            Returns
            -------
            skrf.Network
                Network of S-parameter measurements.
            """
            ntwk = skrf.Network(frequency=self.frequency, s=self.active_trace_sdata)

            return ntwk

        def get_sdata(self, a: int | str, b: int | str) -> skrf.Network:
            """Set the parameter to measure to Sab and perform a sweep.

            Parameters
            ----------
            a : int or str
                S-parameter index 1.
            b : int or str
                S-parameter index 2.

            Returns
            -------
            skrf.Network
                S-parameter network.
            """
            param = f"S{a}{b}"
            self.param_def = param

            self.sweep()

            ntwk = skrf.Network(frequency=self.frequency, s=self.active_trace_sdata)

            return ntwk

        def get_snp_network(self) -> skrf.Network:  # noqa: D102
            raise NotImplementedError

        def sweep(self) -> None:
            """Set analyzer to perform a single sweep using the current state."""
            self.parent.trigger_single()
            self.parent._resource.clear()

            # wait for sweep to complete
            self.query("*OPC?")

    def __init__(self, address: str, backend: str = "@py") -> None:
        super().__init__(address, backend)

        self._resource.read_termination = "\n"
        self._resource.write_termination = "\n"

        self.allocate_channels(1)
        self.active_channel = self.ch1

        self.model = self.id.strip().split(", ")[1]
        if self.model not in self._models:
            print(
                f"WARNING: This model ({self.model}) has not been tested with scikit-rf.",
                file=sys.stderr,
            )

    def _supports(self, feature: str) -> bool:
        model_config = self._models.get(self.model, self._models["default"])
        return feature not in model_config["unsupported"]

    def _model_param(self, param: str):
        model_config = self._models.get(self.model, self._models["default"])
        return model_config[param]

    trigger_source = vna.VNA.command(
        get_cmd="TRIG:SOUR?",
        set_cmd="TRIG:SOUR <arg>",
        doc="""The source of the sweep trigger signal.

        Stimulus > Trigger > Trigger Source""",
        validator=EnumValidator(TriggerSource),
    )

    def read_next_error(self) -> tuple[int, str]:
        """Read the next error.

        Returns
        -------
        tuple of (int, str)
            Error code and message.

        Raises
        ------
        ValueError
            If the error format is unknown.
        """
        err = self.query("SYST:ERR?")
        if err is None:
            err = ""
        pattern = re.compile(r"^\s*(?P<num>[+-]?\d+)\s*,\s*(?P<msg>.+?)\s*$")
        match = pattern.match(err)
        if match:
            return int(match.group("num")), match.group("msg")
        msg = "Unknown error format."
        raise ValueError(msg)

    def clear(self) -> None:
        """Clear analyzer state.

        Clears the following:

        - Error Queue
        - Status Byte Register
        - Standard Event Status Register
        - Operation Status Event Register
        - Questionable Status Event Register
        - Questionable Limit Status Event Register
        - Questionable Limit Channel Status Event Register

        No equivalent softkey.
        """
        self.write("*CLS")

    def reset(self) -> None:
        """Resets the Analyzer to the factory settings.

        System > Preset > OK
        """
        self.write("SYST:PRES")

    max_chan = vna.VNA.command(
        get_cmd="SERV:CHAN:COUN?",
        doc="""Reads out the maximum number of the analyzer channels.

        No equivalent softkey.""",
        validator=IntValidator(),
    )

    abort = vna.VNA.command(
        set_cmd="ABOR",
        doc="""Aborts a sweep.
        Channels in with Single trigger state move to the Hold state.
        Channels with the Continuous trigger state move to the waiting state.

        Stimulus > Trigger > Restart""",
    )

    trigger_scope = vna.VNA.command(
        get_cmd="TRIG:SCOP?",
        set_cmd="TRIG: SCOP <arg>",
        doc="""The trigger scope determines the response on the trigger signal arrival.
        ALL triggers all channels; ACTIVE triggers the active channel.

        Stimulus > Trigger > Trigger Scope > {All Channels | Active Channel}""",
        validator=EnumValidator(TriggerScope),
    )

    @property
    def active_channel(self) -> Channel | None:
        """Active channel of the analyzer.

        Returns
        -------
        Channel or None
            Active channel, or None if the analyzer has no active channel.
        """
        channel = self.query("SERV:CHAN:ACT?")
        return getattr(self, f"ch{channel}", None)

    @active_channel.setter
    def active_channel(self, ch: int | vna.Channel) -> None:
        """Set the active channel.

        Parameters
        ----------
        ch : int or vna.Channel
            Channel object or channel number.

        Raises
        ------
        TypeError
            If `ch` is not an integer or Channel.
        """
        if isinstance(ch, vna.Channel):
            chnum = ch.cnum
        elif isinstance(ch, int):
            chnum = ch
            ch = getattr(self, f"ch{ch}")
        else:
            msg = f"Expected Channel or int, got {ch!r}"
            raise TypeError(msg)

        self.write(f"DISP:WIND{chnum}:ACT")

    @property
    def query_format(self) -> vna.ValuesFormat:
        """Return format from the Analyzer software.

        Returns
        -------
        vna.ValuesFormat
            Current values format.
        """
        fmt = self.query("FORM:DATA?")
        if fmt == "ASC":
            self._values_fmt = vna.ValuesFormat.ASCII
        elif fmt == "REAL32":
            self._values_fmt = vna.ValuesFormat.BINARY_32
        elif fmt == "REAL":
            self._values_fmt = vna.ValuesFormat.BINARY_64
        return self._values_fmt

    @query_format.setter
    def query_format(self, fmt: vna.ValuesFormat) -> None:
        if fmt == vna.ValuesFormat.ASCII:
            self._values_fmt = vna.ValuesFormat.ASCII
            self.write("FORM:DATA ASC")
        elif fmt == vna.ValuesFormat.BINARY_32:
            self._values_fmt = vna.ValuesFormat.BINARY_32
            self.write("FORM:BORD SWAP")
            self.write("FORM:DATA REAL32")
        elif fmt == vna.ValuesFormat.BINARY_64:
            self._values_fmt = vna.ValuesFormat.BINARY_64
            self.write("FORM:BORD SWAP")
            self.write("FORM:DATA REAL")

    def allocate_channels(self, ch_code: int) -> None:
        """Allocate channels.

        Channels start in the Continuous trigger state.

        Parameters
        ----------
        ch_code : int
            Channel window code. Does not correspond to the number of channels.
            The number of window codes is 16. Must be less than or equal
            to the maximum supported number of channels.

        Raises
        ------
        ValueError
            If `ch_code` is greater than the maximum supported number.
        """
        max_chan = self.max_chan
        if ch_code > max_chan:
            msg = f"{ch_code} > {max_chan}. {self.model} only supports {max_chan}."
            raise ValueError(msg)
        for ch in self.channels:
            self.delete_channel(ch.cnum)
        for ch in range(1, ch_code + 1):
            self.write(f"DISP:SPL {ch}")
            self.create_channel(ch, f"Channel {ch}")

    def trigger_single(self, immediate: bool = False) -> None:
        """Generate a trigger signal to initiate a sweep.

        Parameters
        ----------
        immediate : bool, optional
            Whether to wait for the end of the current sweep (default: False).
        """
        # Analyzer needs to have have trigger source BUS in order to trigger using SCPI/COM commands.
        self.trigger_source = TriggerSource.BUS
        # put into continuous mode
        self.trigger_cont = True
        scpi_cmd = "TRIG:SING" if not immediate else "TRIG"
        self.write(scpi_cmd)
